options
{
    LOOKAHEAD = 1;
}
PARSER_BEGIN(Grammar)

import pt.up.fe.comp.jmm.report.Report;
// TODO: import.

public class Grammar{
    //private List<Report> report = new ArrayList<>();
    // TODO: get report
    /* List<Report> getReport(){
    }*/
}

PARSER_END(Grammar)

// See https://javacc.github.io/javacc/tutorials/token-manager.html
// Special tokens are like tokens, except that they are permitted to appear anywhere in the input file.
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT:"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n") >
}

SKIP :
{
	" " | "\r" | "\t"  | "\n"
	| "/*" : WithinComment
}

// Goes to the withinComment state.
<WithinComment> SKIP:
{
    "*/": DEFAULT   // Exiting the skip state.
}

// Continues on the WithinState while...
<WithinComment> MORE : {
    <~[]>
}

TOKEN:
{
    <IMPORT: "import">

    |   < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < INTBRACKETS: "int[]">
    |   < STRING: "String" >

    |   < COMMA: "," >
    |   < DOT: ".">
    |   < COLON: ":" >
    |   < SEMICOLON: ";" >
    |   < OPENSQUAREBRACKET: "[">
    |   < CLOSESQUAREBRACKET: "]">
    |   < OPENCURVEBRACKET: "(">
    |   < CLOSECURVEBRACKET: ")">
    |   < OPENBRACKET: "{">
    |   < CLOSEBRACKET: "}">

    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < VOID: "void">
    |   < MAIN: "main">
    |   < PRINTLN: "System.out.println" >
    |   < THIS: "this" >
    |   < EXTENDS: "extends" >
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">

    |   < TRUE: "true">
    |   < FALSE: "false">
    |   < NOT: "!">
    |   < AND: "&&">
    |   < LESS: "<" >
    |   < SUM: "+">
    |   < SUB: "-">
    |   < MULT: "*">
    |   < DIV: "/">
    |   < EQUALS: "=">


    |   < IF: "if">
    |   < ELSE: "else">
    |   < WHILE: "while">

    |   < IDENTIFIER:  ("$" | <LETTER>) ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)*
                     | ("_" ("_" | "$" | <LETTER> | <DIGIT> | <UNDERSCORE>)+) >
    |   < LETTER: ["a"-"z","A"-"Z"] >
    |   < UNDERSCORE: "_" >
    |   < INTEGERLITERAL: (<DIGIT>)+ >
    |   < DIGIT: ["0"-"9"] >

}


SimpleNode Program(): {}
{
    ImportDeclaration() ClassDeclaration() <EOF> { return jjtThis; }
}

void ImportDeclaration(): {}
{
    (<IMPORT> [<STATIC>] <IDENTIFIER> (LOOKAHEAD(2) <DOT> <IDENTIFIER>)* [<DOT> <MULT>] <SEMICOLON> )*
}


void ClassDeclaration(): {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <OPENBRACKET> (VarDeclaration())* (MethodDeclaration())* <CLOSEBRACKET>
}


void VarDeclaration() :{}
{
    Type() <IDENTIFIER> #identifier <SEMICOLON>
}

 void MethodDeclaration():{}
 {
    <PUBLIC> ( MethodGeneric() | MethodMain())
 }

 void MethodBody() : {}
{
    (LOOKAHEAD(2) VarDeclaration())* (Statement())*
}

void MethodMain(): {}
{
    <STATIC> <VOID> <MAIN> <OPENCURVEBRACKET> StringArray() <CLOSECURVEBRACKET>
    <OPENBRACKET>
        MethodBody()
    <CLOSEBRACKET>

}

void StringArray() : {}
{
    <STRING> <OPENSQUAREBRACKET> <CLOSESQUAREBRACKET> <IDENTIFIER>
}

void MethodGeneric(): {}
{
    Type() <IDENTIFIER> <OPENCURVEBRACKET> [Arguments()] <CLOSECURVEBRACKET>
    <OPENBRACKET>
        MethodBody()
        Return()
    <CLOSEBRACKET>
}

void Arguments() : {}
{
    Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*
}

void Return() : {}
{
    <RETURN> RootExpression() <SEMICOLON>
}

void Type(): {}
{
    <INTBRACKETS> | <BOOLEAN> | <INT> | <STRING> | <IDENTIFIER>
}

void RootExpression() #RootExpression :{}
{
    ExpressionNext1() AndExpression()
}

void AndExpression():{}
{
    <AND> ExpressionNext1() AndExpression()
    | {}
}

void ExpressionNext1(): {}
{
    ExpressionNext2() LessExpression()
}

void LessExpression(): {}
{
    <LESS> ExpressionNext2() LessExpression()
    | {}
}

void ExpressionNext2(): {}
{
    ExpressionNext3() AddSubExpression()
}

void AddSubExpression(): {}
{
    <SUM> ExpressionNext3() AddSubExpression()
    |<SUB> ExpressionNext3() AddSubExpression()
    | {}
}

void ExpressionNext3()  : {}
{
    ExpressionNext4()

    MultDivExpression()
}

void MultDivExpression(): {}
{
    <MULT> ExpressionNext4() MultDivExpression()
    | <DIV> ExpressionNext4() MultDivExpression()
    | {}
}

/* Se estiver mal Ã© a partir de aqui */
void ExpressionNext4() : {}
{
    NotExpression() ExpressionNext5()
}

void NotExpression() : {}
{
    <NOT> NotExpression()
    | {}
}

void ExpressionNext5() #Expression5 : {}
{
    EndExpression() DotArrayExpression()
}

/* Perguntar da prioridade do ponto e do array */
void DotArrayExpression() : {}
{

     <DOT> DotMethod() DotArrayExpression() #DOT
    | ArrayAccess()  DotArrayExpression() #ARRAY
    | {}

}

void DotMethod() #DotMethod: {}
{
    <LENGTH>
    | <IDENTIFIER>
        <OPENCURVEBRACKET>
            [RootExpression()
            (<COMMA> RootExpression())*]
        <CLOSECURVEBRACKET>
}

void ArrayAccess() #ArrayAccess: {}
{
    <OPENSQUAREBRACKET> RootExpression() <CLOSESQUAREBRACKET>
}

void EndExpression() #EndExpression: {}
{
    EndValue()
    | NewExpression()
    | ParentesisExpression()
}

void EndValue() #EndValue: {}
{
    <INTEGERLITERAL>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
}

void NewExpression() #NewValue: {}
{
    <NEW> (<INT> <OPENSQUAREBRACKET> RootExpression() <CLOSESQUAREBRACKET>
        | <IDENTIFIER> <OPENCURVEBRACKET> <CLOSECURVEBRACKET>)
}

void ParentesisExpression() #ParentesisExpression: {}
{
    <OPENCURVEBRACKET> RootExpression() <CLOSECURVEBRACKET>
}

void Statement() #Statment: {}
{
    <OPENBRACKET> (Statement())* <CLOSEBRACKET>
    | IfElseStatement()
    | WhileStatment()
    // TODO: error with a[2] = a.length; or a = a[2].length;
    /*
    | Expression , ";"
    | Identifier , "=" , Expression , ";"
    | Identifier , "[" , Expression , "]" , "=" , Expression , ";"
     */
    | RootExpression() (Assignment())? <SEMICOLON>
    /*
    | LOOKAHEAD(2) RootExpression() <SEMICOLON>
    | LOOKAHEAD(2) <IDENTIFIER> <OPENSQUAREBRACKET> RootExpression() <CLOSESQUAREBRACKET> Assignment() <SEMICOLON>
    | LOOKAHEAD(2) <IDENTIFIER> Assignment() <SEMICOLON>
     */

}

void temp(): {}
{
    <IDENTIFIER> ArrayAccess()(
        Assignment() <SEMICOLON>
        | <DOT> DotMethod() DotArrayExpression()
        | <SEMICOLON>
    )

}

void IfElseStatement() #IfElse: {}
{
    <IF> <OPENCURVEBRACKET> RootExpression() <CLOSECURVEBRACKET> Statement() <ELSE> Statement()
}

void Assignment() #Assignment: {}
{
    <EQUALS> RootExpression()
}

// TODO: in the future improve. Access the report.
void WhileStatment() #WhileStatment : {}
{
    <WHILE> <OPENCURVEBRACKET>
    try{
         RootExpression() <CLOSECURVEBRACKET>
    } catch(ParseException e){
        System.out.println(e.toString()) ;
        Token t;
        int counter = 0;
        int openCurvedCounter = 1, closeCurvedCounter= 0;
        Boolean NotMatch = false;

        do {
           t = getToken(1);

           if (t.kind != OPENBRACKET) getNextToken();
           else break;
           if (t.kind == OPENCURVEBRACKET) openCurvedCounter++;
           else if (t.kind == CLOSECURVEBRACKET) closeCurvedCounter++;


        } while (openCurvedCounter != closeCurvedCounter && t.kind != EOF);
    }
    Statement()
}
