options
{
    LOOKAHEAD=2;
}
PARSER_BEGIN(Grammar)

public class Grammar{}

PARSER_END(Grammar)

SKIP :
{
	" " | "\r" | "\t"  | "\n"
}

TOKEN:
{
        < INT: "int" >
    |   < BOOLEAN: "boolean" >
    |   < INTBRACKETS: "int[]">
    |   < STRING: "String" >

    |   < COMMA: "," >
    |   < DOT: ".">
    |   < COLON: ":" >
    |   < SEMICOLON: ";" >
    |   < OPENSQUAREBRACKET: "[">
    |   < CLOSESQUAREBRACKET: "]">
    |   < OPENCURVEBRACKET: "(">
    |   < CLOSECURVEBRACKET: ")">
    |   < OPENBRACKET: "{">
    |   < CLOSEBRACKET: "}">

    |   < CLASS: "class">
    |   < PUBLIC: "public">
    |   < STATIC: "static">
    |   < VOID: "void">
    |   < MAIN: "main">
    |   < PRINTLN: "System.out.println" >
    |   < THIS: "this" >
    |   < EXTENDS: "extends" >
    |   < RETURN: "return" >
    |   < LENGTH: "length">
    |   < NEW: "new">

    |   < TRUE: "true">
    |   < FALSE: "false">
    |   < NOT: "!">
    |   < AND: "&&">
    |   < LESS: "<" >
    |   < SUM: "+">
    |   < SUB: "-">
    |   < MULT: "*">
    |   < EQUALS: "=">

    |   < IF: "if">
    |   < ELSE: "else">
    |   < WHILE: "while">

    |   < IDENTIFIER: <LETTER> (<LETTER> | <DIGIT> | <UNDERSCORE>)*>
    |   < LETTER: ["a"-"z","A"-"Z"] >
    |   < UNDERSCORE: "_" >
    |   < INTEGERLITERAL: (<DIGIT>)+ >
    |   < DIGIT: ["0"-"9"] >

}

SimpleNode Goal(): {}
{
    MainClass()

    <EOF> {return jjtThis;} /*(ClassDeclaration())* <LF>  {return jjtThis;} // Java code inside brackets*/
}


void ClassDeclaration() #void: {}
{
    <CLASS> <IDENTIFIER> [<EXTENDS> <IDENTIFIER>] <OPENBRACKET> (VarDeclaration())* (MethodDeclaration())* <CLOSEBRACKET>
}

void MainClass() #void: {}
{
    <CLASS> <IDENTIFIER> <OPENBRACKET>
    <PUBLIC> <STATIC> <VOID> <MAIN> <OPENCURVEBRACKET> <STRING> <OPENSQUAREBRACKET> <CLOSESQUAREBRACKET> <IDENTIFIER> <CLOSECURVEBRACKET>
        <OPENBRACKET>
            Statement()
        <CLOSEBRACKET>
   <CLOSEBRACKET>
}

void VarDeclaration() #void:{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

 void MethodDeclaration() #void:{}
 {
    <PUBLIC> Type() <IDENTIFIER>
    // arguments
    <OPENCURVEBRACKET> [Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*] <CLOSECURVEBRACKET>
    // body
    <OPENSQUAREBRACKET> (VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> <CLOSESQUAREBRACKET>
 }

void Type() #void: {}
{
    <INTBRACKETS> | <BOOLEAN> | <INT> | <STRING> | <IDENTIFIER>
}

void Expression() #void: {}
{
     <INTEGERLITERAL>  Expression1()
    | <TRUE> Expression1()
    | <FALSE> Expression1()
    | <IDENTIFIER> Expression1()
    | <THIS> Expression1()
    | <NEW> <INT> <OPENSQUAREBRACKET> Expression() <CLOSESQUAREBRACKET> Expression1()
    | <NEW> <IDENTIFIER> <OPENCURVEBRACKET> <CLOSECURVEBRACKET> Expression1()
    | <NOT> Expression() Expression1()
    | <OPENCURVEBRACKET> Expression() <CLOSECURVEBRACKET> Expression1()
}

void Expression1() #void: {}
{
    (<AND> | <LESS> | <SUM> | <SUB> | <MULT>) Expression() Expression1()
    | <OPENSQUAREBRACKET> Expression() <CLOSESQUAREBRACKET> Expression1()
    | <DOT> <LENGTH> Expression1()
    | <DOT> <IDENTIFIER> <OPENCURVEBRACKET> [Expression() (<COMMA> Expression())*] <CLOSECURVEBRACKET> Expression1()
    | {}
}

void Statement() #void: {}
{
    <OPENBRACKET> Statement() <CLOSEBRACKET>
    | <IF> <OPENCURVEBRACKET> Expression() <CLOSECURVEBRACKET> Statement() <ELSE> Statement()
    | <WHILE> <OPENCURVEBRACKET> Expression() <CLOSECURVEBRACKET> Statement()
    | <PRINTLN> <OPENCURVEBRACKET> Expression() <CLOSECURVEBRACKET> <SEMICOLON>
    | <IDENTIFIER> <EQUALS> Expression() <SEMICOLON>
    | <IDENTIFIER> <OPENSQUAREBRACKET> Expression() <CLOSESQUAREBRACKET> <EQUALS> Expression() <SEMICOLON>
}

