MonteCarloPi{
	.construct MonteCarloPi().V {
		invokespecial(this, "<init>").V;
	}
	.method public performSingleEstimate().bool{
		t1.i32 :=.i32 0.i32 -.i32 100.i32;
		rand1.i32 :=.i32 invokestatic(MathUtils, "random", t1.i32, 100.i32).i32;
		t2.i32 :=.i32 0.i32 -.i32 100.i32;
		rand2.i32 :=.i32 invokestatic(MathUtils, "random", t2.i32, 100.i32).i32;
		t3.i32 :=.i32 rand1.i32 *.i32 rand1.i32;
		t4.i32 :=.i32 rand2.i32 *.i32 rand2.i32;
		t5.i32 :=.i32 t3.i32 +.i32 t4.i32;
		squareDist.i32 :=.i32 t5.i32 /.i32 100.i32;
		if (squareDist.i32 <.i32 100.i32) goto then1;
		else1:
			in_circle.bool :=.bool 0.bool;
			goto endif1;
		then1:
			in_circle.bool :=.bool 1.bool;
		endif1:
			ret.bool in_circle.bool;
	}
	.method public estimatePi100(n.i32).i32{
		samples_so_far.i32 :=.i32 0.i32;
		samples_in_circle.i32 :=.i32 0.i32;
		Loop1:
			if (samples_so_far.i32 <.i32 $1.n.i32) goto Body1;
			goto EndLoop1;
		Body1:
			t6.bool :=.bool invokevirtual(this,"performSingleEstimate").bool;
			if (t6.bool &&.bool 1.bool) goto then2;
			else2:
				goto endif2;
			then2:
				samples_in_circle.i32 :=.i32 samples_in_circle.i32 +.i32 1.i32;
			endif2:
				samples_so_far.i32 :=.i32 samples_so_far.i32 +.i32 1.i32;
				goto Loop1;
		EndLoop1:
			t7.i32 :=.i32 samples_in_circle.i32 /.i32 $1.n.i32;
			pi_estimate.i32 :=.i32 400.i32 *.i32 t7.i32;
			ret.i32 pi_estimate.i32;
	}
	.method public static main(args.array.String).V{
		num_samples.i32 :=.i32 invokestatic(ioPlus, "requestNumber").i32;
		t8.MonteCarloPi :=.MonteCarloPi new(MonteCarloPi).MonteCarloPi;
		invokespecial(t8.MonteCarloPi,"<init>").V;
		pi_estimate_times_100.i32 :=.i32 invokevirtual(t8.MonteCarloPi, "estimatePi100", num_samples.i32).i32;
		invokestatic(ioPlus, "printResult", pi_estimate_times_100.i32).V;
		ret.V;
	}
}